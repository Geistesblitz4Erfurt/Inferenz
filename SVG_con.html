<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Architect: MONOLITH V13.3 (Print Button)</title>
    
    <!-- PDF Generation - NUR jsPDF (zuverl√§ssig!) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <style>
        :root {
            --bg: #0d1117; --panel: #161b22; --border: #30363d;
            --primary: #2ea043; --text: #e6edf3; --text-dim: #8b949e;
            --code-bg: #0d1117; --success: #238636; --error: #da3633;
        }
        * { box-sizing: border-box; outline: none; }
        body {
            background: var(--bg); color: var(--text); font-family: monospace;
            margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        }

        /* HEADER */
        header { 
            padding: 15px 20px; border-bottom: 1px solid var(--border); background: var(--panel); display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; font-family: -apple-system, sans-serif;
        }
        h1 { margin: 0; font-size: 1.2rem; font-weight: 600; letter-spacing: 0.5px; }
        .tag { font-size: 0.7rem; padding: 2px 8px; border-radius: 10px; border: 1px solid var(--primary); color: var(--primary); margin-left: 10px; text-transform: uppercase; font-weight: bold; }

        /* LAYOUT */
        .layout { display: grid; grid-template-columns: 340px 1fr; height: calc(100vh - 60px); overflow: hidden; }
        
        /* SIDEBAR */
        .sidebar { border-right: 1px solid var(--border); padding: 20px; overflow-y: auto; background: var(--bg); display: flex; flex-direction: column; gap: 20px; }
        
        .input-group { margin-bottom: 15px; }
        label { display: block; font-size: 0.7rem; font-weight: bold; color: var(--text-dim); margin-bottom: 5px; text-transform: uppercase; font-family: -apple-system, sans-serif; }
        input[type="text"], input[type="number"] {
            width: 100%; background: #010409; border: 1px solid var(--border); color: var(--text); padding: 8px; border-radius: 6px; font-family: monospace;
        }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--primary); }
        
        .drop-zone {
            border: 2px dashed var(--border); border-radius: 6px; padding: 30px; text-align: center; cursor: pointer; transition: 0.2s; background: rgba(255,255,255,0.01);
        }
        .drop-zone:hover { border-color: var(--primary); background: rgba(46, 160, 67, 0.15); }

        .btn { width: 100%; padding: 12px; border-radius: 6px; border: 1px solid var(--border); background: var(--panel); color: var(--text); cursor: pointer; font-weight: 600; transition: 0.2s; font-size: 0.85rem; font-family: -apple-system, sans-serif; }
        .btn:hover { background: var(--border); }
        .btn-primary { background: var(--primary); border-color: rgba(255,255,255,0.1); color: white; }
        .btn-primary:hover:not(:disabled) { background: #3fb950; }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }

        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; font-family: -apple-system, sans-serif; }
        .toggle-label { font-size: 0.8rem; color: var(--text); }

        /* MAIN CONTENT */
        .main-view { display: flex; flex-direction: column; height: 100%; overflow: hidden; background: #010409; position: relative; }
        
        .tabs { display: flex; overflow-x: auto; background: var(--panel); border-bottom: 1px solid var(--border); scrollbar-width: none; flex-shrink: 0; }
        .tab-btn {
            padding: 12px 16px; background: transparent; border: none; color: var(--text-dim); cursor: pointer; font-size: 0.8rem; white-space: nowrap; border-right: 1px solid var(--border); border-bottom: 2px solid transparent; font-family: -apple-system, sans-serif;
        }
        .tab-btn:hover { color: var(--text); background: rgba(255,255,255,0.02); }
        .tab-btn.active { color: var(--primary); border-bottom-color: var(--primary); background: var(--bg); font-weight: bold; }

        .view-container { flex: 1; position: relative; display: none; flex-direction: column; overflow: hidden; }
        .view-container.active { display: flex; }

        .toolbar { padding: 10px 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: var(--bg); flex-shrink: 0; font-family: -apple-system, sans-serif; }
        .std-badge { font-family: monospace; font-size: 0.75rem; color: var(--success); background: rgba(35, 134, 54, 0.15); padding: 2px 8px; border-radius: 4px; }

        textarea {
            flex: 1; width: 100%; border: none; background: #0d1117; color: #e6edf3; padding: 20px; font-family: 'SFMono-Regular', Consolas, monospace; font-size: 12px; resize: none; outline: none; line-height: 1.5;
        }

        .preview-stage {
            flex: 1; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden;
            background-image: linear-gradient(45deg, #161b22 25%, transparent 25%), linear-gradient(-45deg, #161b22 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #161b22 75%), linear-gradient(-45deg, transparent 75%, #161b22 75%);
            background-size: 20px 20px;
        }
        .preview-stage svg { max-width: 90%; max-height: 80vh; z-index: 2; filter: drop-shadow(0 10px 30px rgba(0,0,0,0.5)); image-rendering: pixelated; }
        #bgLayer { position: absolute; inset: 0; z-index: 1; pointer-events: none; }

        #logPanel { font-family: monospace; font-size: 0.7rem; color: var(--text-dim); max-height: 150px; overflow-y: auto; padding: 10px; background: #010409; border-top: 1px solid var(--border); }
        .log-line { margin-bottom: 4px; border-left: 2px solid transparent; padding-left: 5px; }
        .log-line.active { border-left-color: var(--primary); color: var(--text); }
        .log-line.error { border-left-color: var(--error); color: var(--error); }

        .progress-bar { height: 3px; background: var(--border); width: 100%; position: absolute; top: 0; left: 0; z-index: 10; }
        .progress-fill { height: 100%; width: 0%; background: var(--success); transition: width 0.1s linear; }

        /* MOBILE OPTIMIZATION */
        @media (max-width: 900px) {
            body { height: auto; min-height: 100vh; overflow-y: auto; display: block; }
            .layout { display: flex; flex-direction: column; height: auto; overflow: visible; }
            .sidebar { width: 100%; border-right: none; border-bottom: 1px solid var(--border); height: auto; padding-bottom: 30px; }
            .main-view { height: 70vh; min-height: 500px; border-top: 5px solid var(--bg); }
            .toolbar { flex-wrap: wrap; gap: 10px; padding: 10px; }
            .toolbar > div { width: 100%; display: flex; justify-content: flex-end; gap: 5px; }
            .toolbar button { flex: 1; text-align: center; font-size: 0.75rem; }
            header { flex-direction: column; align-items: flex-start; gap: 5px; }
            header div { align-self: flex-end; }
        }
    </style>
</head>
<body>

    <header>
        <h1>Pixel Architect <span class="tag">MONOLITH</span></h1>
        <div style="font-size:0.8rem; color:var(--text-dim)">V13.3 ‚Ä¢ Force Print ‚Ä¢ Vector Safe</div>
    </header>

    <div class="layout">
        
        <!-- SIDEBAR -->
        <aside class="sidebar">
            <div class="drop-zone" id="dropZone">
                <div style="font-size:2rem; margin-bottom:10px;">üìÇ</div>
                <div id="statusText">Import Image</div>
                <input type="file" id="fileInput" hidden accept="image/*">
            </div>
            
            <div style="display:flex; gap:5px;">
                <input type="text" id="urlInput" placeholder="https://...">
                <button class="btn" style="width:auto;" onclick="App.loadUrl()">Load</button>
            </div>

            <hr style="border:0; border-top:1px solid var(--border); width:100%;">

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                <div class="input-group">
                    <label>Breite (px)</label>
                    <input type="number" id="inWidth" value="128">
                </div>
                <div class="input-group">
                    <label>H√∂he (px)</label>
                    <input type="number" id="inHeight" value="128">
                </div>
            </div>

            <div class="input-group">
                <label>Kontrast (Standard: 0)</label>
                <input type="range" id="contrast" min="-50" max="50" value="0">
            </div>

            <div class="input-group">
                <label>Farb-Filter (Standard: 0)</label>
                <input type="range" id="sensitivity" min="0" max="40" value="0">
            </div>

            <hr style="border:0; border-top:1px solid var(--border); width:100%;">
            
            <div class="toggle-row">
                <span class="toggle-label" style="font-weight:bold;">Smart Background</span>
                <input type="checkbox" id="smartBg" checked disabled>
            </div>

            <div class="toggle-row">
                <span class="toggle-label" style="font-weight:bold; color:var(--primary);">Auto-Trim (Zuschneiden)</span>
                <input type="checkbox" id="autoTrim" checked>
            </div>

            <hr style="border:0; border-top:1px solid var(--border); width:100%;">

            <div style="display:flex; align-items:center; gap:10px; margin-bottom:20px;">
                <label style="margin:0;">Preview BG:</label>
                <input type="color" id="bgColor" value="#161b22">
                <input type="range" id="bgAlpha" min="0" max="100" value="0" style="flex:1">
            </div>

            <button id="procBtn" class="btn btn-primary" onclick="App.startPipeline()" disabled>RUN PIPELINE</button>
            
            <div id="logPanel">
                <div class="log-line">System bereit.</div>
            </div>
        </aside>

        <!-- MAIN VIEW -->
        <main class="main-view">
            <div class="progress-bar"><div class="progress-fill" id="progFill"></div></div>
            
            <div class="tabs" id="tabBar">
                <!-- Tabs injected here -->
            </div>

            <div id="viewsRoot" style="flex:1; position:relative; overflow:hidden; display:flex; flex-direction:column;">
                <!-- PREVIEW -->
                <div id="view-preview" class="view-container active">
                    <div class="preview-stage">
                        <div id="bgLayer"></div>
                        <div id="svgContainer" style="color:var(--text-dim)">Warte auf Start...</div>
                    </div>
                    <div class="toolbar" style="border-top:1px solid var(--border); border-bottom:none;">
                        <span class="std-badge" style="display:none;">PREVIEW</span>
                        <div style="display:flex; gap:10px; width:100%;">
                            <button class="btn" style="flex:1;" onclick="App.download('svg')">SVG Download</button>
                            <button class="btn btn-primary" style="flex:1;" onclick="App.downloadPDF()">üìÑ PDF Speichern</button>
                            <button class="btn" style="flex:1;" onclick="App.download('html')">Bundle</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- WORKER: RETURNS RAW DATA (NO LAZY STRINGS) -->
    <script id="worker-code" type="javascript/worker">
        const toHex = (r, g, b) => "#" + ((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).toUpperCase();
        const snap = (v, s) => s <= 0 ? v : Math.min(255, Math.round(v / Math.max(1, s*4)) * Math.max(1, s*4));

        self.onmessage = function(e) {
            try {
                const { pixels: buffer, width, height, config } = e.data;
                const { sensitivity, contrast, autoTrim } = config;
                const pixels = new Uint8ClampedArray(buffer);
                const contrastFactor = (259 * (contrast + 255)) / (255 * (259 - contrast));
                
                const bgR = pixels[0], bgG = pixels[1], bgB = pixels[2];
                const tol = 15 + sensitivity;
                
                const validMap = new Uint8Array(width * height);
                let minX = width, maxX = 0, minY = height, maxY = 0;
                let hasContent = false;

                for(let i=0; i<width*height; i++) {
                    const idx = i*4;
                    const r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2], a = pixels[idx+3];
                    
                    let isBg = false;
                    if(Math.abs(r-bgR)<tol && Math.abs(g-bgG)<tol && Math.abs(b-bgB)<tol) isBg = true;
                    
                    if(a > 20 && !isBg) {
                        validMap[i] = 1;
                        const x = i % width;
                        const y = Math.floor(i / width);
                        if(x < minX) minX = x; if(x > maxX) maxX = x;
                        if(y < minY) minY = y; if(y > maxY) maxY = y;
                        hasContent = true;
                    }
                }

                if(!hasContent) {
                    self.postMessage({ type: 'done', result: { meta: {w:width, h:height}, rects: {}, grid: [] } });
                    return;
                }

                const startX = autoTrim ? minX : 0;
                const startY = autoTrim ? minY : 0;
                const finalW = autoTrim ? (maxX - minX + 1) : width;
                const finalH = autoTrim ? (maxY - minY + 1) : height;

                // RAW DATA ACCUMULATOR
                const rectData = {};
                
                // VISUAL GRID for ASCII
                const gridData = new Array(finalW * finalH).fill(null);

                for(let y = 0; y < finalH; y++) {
                    if(y % 10 === 0) self.postMessage({ type: 'progress', val: (y/finalH)*100 });
                    let currentHex = null;
                    let runStart = -1;
                    const srcY = y + startY;

                    for(let x = 0; x < finalW; x++) {
                        const srcX = x + startX;
                        const i = srcY * width + srcX;
                        let hex = null;

                        if(validMap[i] === 1) {
                            const idx = i * 4;
                            let r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2];
                            
                            if(contrast !== 0) {
                                r = Math.max(0, Math.min(255, contrastFactor * (r - 128) + 128));
                                g = Math.max(0, Math.min(255, contrastFactor * (g - 128) + 128));
                                b = Math.max(0, Math.min(255, contrastFactor * (b - 128) + 128));
                            }
                            if(sensitivity > 0) {
                                r = snap(r, sensitivity); g = snap(g, sensitivity); b = snap(b, sensitivity);
                            }
                            hex = toHex(r, g, b);
                            
                            gridData[y * finalW + x] = hex;
                        }

                        if(hex !== currentHex) {
                            if(currentHex) {
                                if(!rectData[currentHex]) rectData[currentHex] = [];
                                rectData[currentHex].push([runStart, y, x - runStart]);
                            }
                            currentHex = hex;
                            runStart = x;
                        }
                    }
                    if(currentHex) {
                        if(!rectData[currentHex]) rectData[currentHex] = [];
                        rectData[currentHex].push([runStart, y, finalW - runStart]);
                    }
                }

                const result = {
                    meta: { w: finalW, h: finalH },
                    rects: rectData,
                    grid: gridData
                };

                self.postMessage({ type: 'done', result });

            } catch(e) {
                self.postMessage({ type: 'error', msg: e.message });
            }
        };
    </script>

    <!-- APP LOGIC -->
    <script>
        const Generators = {
            makePath: (rects) => {
                let d = "";
                for(let i=0; i<rects.length; i++) {
                    const r = rects[i];
                    d += `M${r[0]},${r[1]}h${r[2]}v1h-${r[2]}z`;
                }
                return d;
            },

            svg: (r) => {
                let paths = "";
                const colors = Object.keys(r.rects).sort();
                colors.forEach(c => {
                    const d = Generators.makePath(r.rects[c]);
                    paths += `<path fill="${c}" d="${d}"/>`;
                });
                return `<?xml version="1.0" encoding="UTF-8"?>\n<svg width="${r.meta.w}" height="${r.meta.h}" viewBox="0 0 ${r.meta.w} ${r.meta.h}" xmlns="http://www.w3.org/2000/svg" shape-rendering="crispEdges">\n${paths}\n</svg>`;
            },

            dxf: (r) => {
                let s = "0\nSECTION\n2\nHEADER\n9\n$ACADVER\n1\nAC1009\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n";
                const colors = Object.keys(r.rects).sort();
                colors.forEach((c, idx) => {
                    const rectList = r.rects[c];
                    const colorCode = (idx % 254) + 1;
                    rectList.forEach(rect => {
                        const x = rect[0], y = rect[1], w = rect[2], h = 1;
                        const y1 = -y, y2 = -(y + h);
                        s += `0\nSOLID\n8\n${c}\n62\n${colorCode}\n`;
                        s += `10\n${x}\n20\n${y1}\n`;   
                        s += `11\n${x+w}\n21\n${y1}\n`; 
                        s += `12\n${x}\n22\n${y2}\n`;   
                        s += `13\n${x+w}\n23\n${y2}\n`; 
                    });
                });
                return s + "0\nENDSEC\n0\nEOF";
            },

            ascii_art: (r) => {
                let s = "";
                for(let y=0; y<r.meta.h; y++) {
                    for(let x=0; x<r.meta.w; x++) {
                        const c = r.grid[y * r.meta.w + x];
                        s += c ? "‚ñà‚ñà" : "  ";
                    }
                    s += "\n";
                }
                return s;
            },

            svg_ascii: (r) => {
                const s = Generators.svg(r);
                const bytes = [];
                for(let i=0; i<s.length; i++) bytes.push(s.charCodeAt(i));
                return bytes.join(', ');
            },

            sql: (r, n) => {
                const json = JSON.stringify(r.rects).replace(/'/g, "''");
                return `-- ANSI SQL Compatible\nCREATE TABLE IF NOT EXISTS assets (name VARCHAR(255) PRIMARY KEY, w INT, h INT, data TEXT);\nINSERT INTO assets (name, w, h, data) VALUES ('${n}', ${r.meta.w}, ${r.meta.h}, '${json}');`;
            },

            php: (r, n) => {
                const svg = Generators.svg(r);
                return `<?php\n\nclass Icon_${n} {\n    public static function getSvg(): string {\n        return <<<'SVG'\n${svg}\nSVG;\n    }\n}`;
            },

            python: (r, n) => {
                const svg = Generators.svg(r);
                return `# Python 3.7+\nfrom dataclasses import dataclass\n\n@dataclass\nclass Icon${n}:\n    def to_svg(self) -> str:\n        return """${svg}"""`;
            },

            rust: (r, n) => {
                const svg = Generators.svg(r);
                return `// Rust Wasm\n#[no_mangle]\npub extern "C" fn icon_${n}() -> *const u8 {\n    r#"${svg}"#.as_ptr()\n}`;
            },

            wasm_js: (r, n) => {
                const svg = Generators.svg(r);
                return `// JS Module\nexport const icon_${n} = \`${svg}\`;`;
            },

            base64: (r) => `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(Generators.svg(r))))}`,
            html: (r, n) => `<!DOCTYPE html><html><head><style>body{background:#222;display:grid;place-items:center;height:100vh;}svg{max-width:90vmin;}</style></head><body>${Generators.svg(r)}</body></html>`,
            json: (r) => JSON.stringify(r.rects, null, 2),
            xml: (r) => {
                let l = "";
                for(let c in r.rects) l+=`<layer color="${c}">${Generators.makePath(r.rects[c])}</layer>`;
                return `<?xml version="1.0"?><asset w="${r.meta.w}" h="${r.meta.h}">${l}</asset>`;
            },
            tailwind: (r) => `<div class="w-[${r.meta.w}px] h-[${r.meta.h}px] bg-[url('${Generators.base64(r)}')] bg-cover"></div>`
        };

        const FORMATS = [
            { id: 'ascii_art', label: 'ASCII Art', std: 'Visual', ext: 'txt', mime: 'text/plain' },
            { id: 'svg_ascii', label: 'SVG Bytes', std: 'Decimal', ext: 'txt', mime: 'text/plain' },
            { id: 'svg', label: 'SVG', std: 'W3C 1.1', ext: 'svg', mime: 'image/svg+xml' },
            { id: 'dxf', label: 'DXF', std: 'AutoCAD', ext: 'dxf', mime: 'application/dxf' },
            { id: 'sql', label: 'SQL', std: 'ANSI', ext: 'sql', mime: 'text/plain' },
            { id: 'php', label: 'PHP', std: 'Class', ext: 'php', mime: 'text/x-php' },
            { id: 'python', label: 'Python', std: 'Dataclass', ext: 'py', mime: 'text/x-python' },
            { id: 'rust', label: 'Rust', std: 'Wasm', ext: 'rs', mime: 'text/rust' },
            { id: 'wasm_js', label: 'JS Wasm', std: 'Glue', ext: 'js', mime: 'text/javascript' },
            { id: 'html', label: 'HTML', std: 'HTML5', ext: 'html', mime: 'text/html' },
            { id: 'base64', label: 'Base64', std: 'RFC 2397', ext: 'txt', mime: 'text/plain' },
            { id: 'json', label: 'JSON', std: 'Raw Data', ext: 'json', mime: 'application/json' },
            { id: 'xml', label: 'XML', std: 'W3C', ext: 'xml', mime: 'text/xml' },
            { id: 'tailwind', label: 'Tailwind', std: 'V4', ext: 'html', mime: 'text/html' }
        ];

        const App = {
            worker: null, sourceImage: null, vectorData: null, fileName: 'asset', outputs: {},

            init() {
                const blob = new Blob([document.getElementById('worker-code').textContent], {type: "text/javascript"});
                this.worker = new Worker(URL.createObjectURL(blob));
                this.worker.onmessage = (e) => {
                    if(e.data.type === 'progress') this.updateProgress(e.data.val);
                    else if(e.data.type === 'done') this.runGenerators(e.data.result);
                    else if(e.data.type === 'error') this.log('Error: ' + e.data.msg, 'error');
                };
                this.buildUI();
                this.setupEvents();
            },

            buildUI() {
                const bar = document.getElementById('tabBar');
                const root = document.getElementById('viewsRoot');
                const pBtn = document.createElement('button');
                pBtn.className = 'tab-btn active'; pBtn.innerText = 'üëÅÔ∏è Preview';
                pBtn.onclick = () => this.switchTab('preview');
                bar.appendChild(pBtn);

                FORMATS.forEach(fmt => {
                    const btn = document.createElement('button');
                    btn.className = 'tab-btn'; btn.innerText = fmt.label;
                    btn.onclick = () => this.switchTab(fmt.id);
                    btn.id = `tab-${fmt.id}`;
                    bar.appendChild(btn);

                    const div = document.createElement('div');
                    div.className = 'view-container';
                    div.id = `view-${fmt.id}`;
                    div.innerHTML = `
                        <div class="toolbar">
                            <span class="std-badge">${fmt.std}</span>
                            <div style="display:flex; gap:10px; width:100%; justify-content:flex-end;">
                                <button class="btn" style="flex:1; max-width:80px; padding:6px 12px; font-size:0.75rem;" onclick="App.copy('${fmt.id}')">Copy</button>
                                <button class="btn" style="flex:1; max-width:80px; padding:6px 12px; font-size:0.75rem;" onclick="App.download('${fmt.id}')">DL</button>
                            </div>
                        </div>
                        <textarea id="out-${fmt.id}" readonly spellcheck="false">Waiting...</textarea>
                    `;
                    root.appendChild(div);
                });
            },

            setupEvents() {
                const el = (id) => document.getElementById(id);
                el('dropZone').onclick = () => el('fileInput').click();
                el('dropZone').ondragover = (e) => { e.preventDefault(); };
                el('dropZone').ondrop = (e) => { e.preventDefault(); this.handleFile(e.dataTransfer.files[0]); };
                el('fileInput').onchange = (e) => this.handleFile(e.target.files[0]);
                el('inWidth').onchange = () => { if(this.sourceImage) el('inHeight').value = Math.round(el('inWidth').value / (this.sourceImage.width/this.sourceImage.height))||1; };
                el('inHeight').onchange = () => { if(this.sourceImage) el('inWidth').value = Math.round(el('inHeight').value * (this.sourceImage.width/this.sourceImage.height))||1; };
                
                const updateBg = () => {
                    const h = el('bgColor').value;
                    const a = el('bgAlpha').value / 100;
                    const r=parseInt(h.slice(1,3),16), g=parseInt(h.slice(3,5),16), b=parseInt(h.slice(5,7),16);
                    el('bgLayer').style.backgroundColor = `rgba(${r},${g},${b},${a})`;
                };
                el('bgColor').addEventListener('input', updateBg);
                el('bgAlpha').addEventListener('input', updateBg);
            },

            log(msg, type='active') {
                const p = document.getElementById('logPanel');
                const div = document.createElement('div');
                div.className = `log-line`;
                div.style.borderLeftColor = type === 'error' ? 'var(--error)' : 'var(--primary)';
                div.style.color = type === 'error' ? 'var(--error)' : 'var(--text)';
                div.innerText = `> ${msg}`;
                p.prepend(div);
            },

            handleFile(file) {
                if(!file) return;
                this.fileName = file.name.split('.')[0].replace(/[^a-zA-Z0-9_]/g, '_');
                const r = new FileReader();
                r.onload = (e) => this.loadImage(e.target.result);
                r.readAsDataURL(file);
            },

            loadUrl() {
                const u = document.getElementById('urlInput').value.trim();
                if(u) this.loadImage('https://corsproxy.io/?' + encodeURIComponent(u));
            },

            loadImage(src) {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    this.sourceImage = img;
                    let w = img.width, h = img.height;
                    if(w > 512) { w = 512; h = Math.round(512/(img.width/img.height)); }
                    document.getElementById('inWidth').value = w;
                    document.getElementById('inHeight').value = h;
                    document.getElementById('statusText').innerText = `Loaded: ${img.width}x${img.height}`;
                    document.getElementById('procBtn').disabled = false;
                    this.log(`Loaded ${w}x${h}`);
                };
                img.src = src;
            },

            startPipeline() {
                if(!this.sourceImage) return;
                document.getElementById('procBtn').disabled = true;
                this.log("Processing...", "active");
                const w = parseInt(document.getElementById('inWidth').value);
                const h = parseInt(document.getElementById('inHeight').value);
                const cvs = document.createElement('canvas');
                cvs.width = w; cvs.height = h;
                const ctx = cvs.getContext('2d');
                ctx.imageSmoothingEnabled = false; 
                ctx.drawImage(this.sourceImage, 0, 0, w, h);
                const pixels = ctx.getImageData(0,0,w,h).data.buffer;
                this.worker.postMessage({
                    pixels, width: w, height: h,
                    config: {
                        sensitivity: parseInt(document.getElementById('sensitivity').value),
                        contrast: parseInt(document.getElementById('contrast').value),
                        autoTrim: document.getElementById('autoTrim').checked
                    }
                }, [pixels]);
            },

            updateProgress(val) {
                document.getElementById('progFill').style.width = val + '%';
            },

            async runGenerators(result) {
                this.vectorData = result;
                document.getElementById('progFill').style.width = '100%';
                this.log(`Result: ${result.meta.w}x${result.meta.h}px`, "success");
                
                // SVG for Preview
                const svg = Generators.svg(result);
                this.outputs['svg'] = svg;
                document.getElementById('svgContainer').innerHTML = svg;

                for (const fmt of FORMATS) {
                    await new Promise(r => setTimeout(r, 0));
                    try {
                        const code = Generators[fmt.id](result, this.fileName);
                        this.outputs[fmt.id] = code;
                        document.getElementById(`out-${fmt.id}`).value = code;
                    } catch(e) {
                        this.log(`Error ${fmt.id}: ${e.message}`, 'error');
                    }
                }
                document.getElementById('procBtn').disabled = false;
                setTimeout(() => document.getElementById('progFill').style.width = '0%', 500);
            },

            switchTab(id) {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.view-container').forEach(c => c.classList.remove('active'));
                if(id === 'preview') {
                    document.querySelector('.tab-btn').classList.add('active'); 
                    document.getElementById('view-preview').classList.add('active');
                } else {
                    document.getElementById(`tab-${id}`).classList.add('active');
                    document.getElementById(`view-${id}`).classList.add('active');
                }
            },

            copy(id) {
                const el = document.getElementById(`out-${id}`);
                el.select(); document.execCommand('copy');
                this.log(`Copied ${id}`);
            },

            // ==========================================
            // FIX: DIRECT DOCUMENT WRITE + BUTTON
            // ==========================================
            // PDF / PRINT SAFE (mit Fallback)
            // ==========================================
            printSafe() {
                if(!this.outputs['svg']) {
                    alert('Bitte zuerst ein Bild vektorisieren!');
                    return;
                }

                this.log('Starte PDF-Export...', 'active');

                // Versuche Pop-up zu √∂ffnen
                let win;
                try {
                    win = window.open("", "_blank", "width=800,height=600");
                } catch(e) {
                    console.error('Pop-up error:', e);
                    win = null;
                }
                
                // Fallback: Wenn Pop-up blockiert, als HTML-Datei downloaden
                if (!win || win.closed || typeof win.closed == 'undefined') {
                    this.log('Pop-up blockiert - erstelle druckbare HTML-Datei...', 'active');
                    
                    // Erstelle HTML zum Downloaden
                    const printHTML = this.generatePrintHTML();
                    const blob = new Blob([printHTML], {type: 'text/html;charset=utf-8'});
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${this.fileName}_PRINT.html`;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 100);
                    
                    alert('‚úì Druckbare HTML-Datei wurde heruntergeladen!\n\n' +
                          'üìÇ √ñffnen Sie die Datei im Browser\n' +
                          'üñ®Ô∏è Dr√ºcken Sie STRG+P (Windows) oder CMD+P (Mac)\n' +
                          'üíæ W√§hlen Sie "Als PDF speichern"');
                    
                    this.log('‚úì Druckbare HTML-Datei heruntergeladen', 'active');
                    return;
                }

                // Pop-up erfolgreich ge√∂ffnet
                const printHTML = this.generatePrintHTML();
                
                try {
                    win.document.open();
                    win.document.write(printHTML);
                    win.document.close();
                    this.log('‚úì Druckvorschau ge√∂ffnet', 'active');
                } catch(e) {
                    console.error('Write error:', e);
                    win.close();
                    alert('Fehler beim √ñffnen der Druckvorschau.\nBitte erlauben Sie Pop-ups f√ºr diese Seite.');
                }
            },

            generatePrintHTML() {
                const svg = this.outputs['svg'];
                return `<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.fileName} - Drucken</title>
    <style>
        * {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
            color-adjust: exact !important;
        }
        @page { 
            margin: 0mm;
            size: auto;
        }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: white;
            overflow: hidden;
        }
        #container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        svg {
            max-width: 90vw;
            max-height: 90vh;
            width: auto;
            height: auto;
            display: block;
            shape-rendering: crispEdges;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        svg path {
            -webkit-print-color-adjust: exact !important;
            print-color-adjust: exact !important;
            color-adjust: exact !important;
        }
        
        /* Print Styles */
        @media print {
            .no-print {
                display: none !important;
            }
            html, body {
                width: 100%;
                height: 100%;
            }
            #container {
                padding: 0;
                height: 100%;
            }
            svg {
                max-width: 100%;
                max-height: 100%;
            }
        }
        
        /* Screen Only */
        @media screen {
            .info-banner {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: #2ea043;
                color: white;
                padding: 15px;
                text-align: center;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
                font-size: 14px;
                z-index: 10000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            }
            .print-btn {
                position: fixed;
                bottom: 30px;
                left: 50%;
                transform: translateX(-50%);
                padding: 18px 40px;
                background: #2ea043;
                color: white;
                border: none;
                border-radius: 50px;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 4px 20px rgba(46, 160, 67, 0.4);
                cursor: pointer;
                z-index: 10001;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
                transition: all 0.3s ease;
            }
            .print-btn:hover {
                background: #3fb950;
                transform: translateX(-50%) scale(1.05);
                box-shadow: 0 6px 25px rgba(46, 160, 67, 0.6);
            }
            .print-btn:active {
                transform: translateX(-50%) scale(0.98);
            }
            #container {
                padding-top: 70px;
                padding-bottom: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="info-banner no-print">
        üìÑ Bereit zum Drucken! Dr√ºcken Sie den Button unten oder verwenden Sie <strong>STRG+P</strong> / <strong>CMD+P</strong>
    </div>
    
    <div id="container">
        ${svg}
    </div>

    <button class="print-btn no-print" onclick="doPrint()">
        üñ®Ô∏è JETZT DRUCKEN / ALS PDF SPEICHERN
    </button>

    <script>
        function doPrint() {
            // Stelle sicher dass alle Farben gesetzt sind
            const svg = document.querySelector('svg');
            if (svg) {
                const paths = svg.querySelectorAll('path');
                paths.forEach(path => {
                    const fill = path.getAttribute('fill');
                    if (fill) {
                        path.style.fill = fill;
                        path.style.webkitPrintColorAdjust = 'exact';
                        path.style.printColorAdjust = 'exact';
                        path.style.colorAdjust = 'exact';
                    }
                });
            }
            
            // Triggere Druck
            window.print();
        }
        
        // Auto-Print nach Laden (nur wenn nicht manuell)
        window.addEventListener('load', function() {
            const svg = document.querySelector('svg');
            if (svg) {
                svg.style.shapeRendering = 'crispEdges';
                
                const paths = svg.querySelectorAll('path');
                paths.forEach(path => {
                    const fill = path.getAttribute('fill');
                    if (fill) {
                        path.style.fill = fill;
                        path.style.webkitPrintColorAdjust = 'exact';
                        path.style.printColorAdjust = 'exact';
                    }
                });
            }
            
            // Automatischer Druck nur in Pop-up (nicht bei manuell ge√∂ffneter Datei)
            if (window.opener) {
                setTimeout(function() {
                    try {
                        window.print();
                    } catch(e) {
                        console.log('Auto-print failed:', e);
                    }
                }, 1000);
            }
        });
        
        // Keyboard Shortcut
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                e.preventDefault();
                doPrint();
            }
        });
    <\/script>
</body>
</html>`;
            },

            // ==========================================
            // DIREKTER PDF-DOWNLOAD (FUNKTIONIERT GARANTIERT!)
            // ==========================================
            async downloadPDF() {
                if(!this.outputs['svg']) {
                    alert('Bitte zuerst ein Bild vektorisieren!');
                    return;
                }

                try {
                    this.log('Erstelle PDF...', 'active');

                    // Hole SVG Element aus der Vorschau
                    const svgContainer = document.getElementById('svgContainer');
                    const svgElement = svgContainer.querySelector('svg');
                    
                    if (!svgElement) {
                        throw new Error('SVG nicht gefunden');
                    }

                    // Hole Dimensionen
                    const width = parseInt(svgElement.getAttribute('width')) || this.vectorData.meta.w;
                    const height = parseInt(svgElement.getAttribute('height')) || this.vectorData.meta.h;
                    
                    // Erstelle Canvas f√ºr Rendering (mit hoher Aufl√∂sung f√ºr Qualit√§t!)
                    const scale = 4; // 4x Aufl√∂sung f√ºr gestochen scharfe Qualit√§t
                    const canvas = document.createElement('canvas');
                    canvas.width = width * scale;
                    canvas.height = height * scale;
                    const ctx = canvas.getContext('2d');
                    
                    // Wei√üer Hintergrund
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Skaliere Context f√ºr hochaufl√∂sendes Rendering
                    ctx.scale(scale, scale);
                    
                    // Rendere SVG auf Canvas
                    const svgString = new XMLSerializer().serializeToString(svgElement);
                    const img = new Image();
                    const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
                    const url = URL.createObjectURL(svgBlob);
                    
                    // Warte auf Bild-Laden
                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            ctx.drawImage(img, 0, 0, width, height);
                            URL.revokeObjectURL(url);
                            resolve();
                        };
                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            reject(new Error('SVG konnte nicht geladen werden'));
                        };
                        img.src = url;
                    });

                    // Konvertiere Canvas zu Bild-Daten
                    const imgData = canvas.toDataURL('image/png');

                    // Erstelle PDF
                    const { jsPDF } = window.jspdf;
                    
                    // Berechne PDF-Dimensionen (A4 optimiert)
                    const aspectRatio = width / height;
                    let pdfWidth, pdfHeight, orientation;
                    
                    if (aspectRatio > 1) {
                        // Querformat
                        orientation = 'landscape';
                        pdfWidth = 297;
                        pdfHeight = 210;
                    } else {
                        // Hochformat
                        orientation = 'portrait';
                        pdfWidth = 210;
                        pdfHeight = 297;
                    }
                    
                    const pdf = new jsPDF({
                        orientation: orientation,
                        unit: 'mm',
                        format: 'a4'
                    });

                    // Berechne Bild-Gr√∂√üe mit Rand
                    const margin = 10; // 10mm Rand
                    const maxWidth = pdfWidth - (2 * margin);
                    const maxHeight = pdfHeight - (2 * margin);
                    
                    let imgWidth, imgHeight;
                    if (aspectRatio > maxWidth / maxHeight) {
                        imgWidth = maxWidth;
                        imgHeight = maxWidth / aspectRatio;
                    } else {
                        imgHeight = maxHeight;
                        imgWidth = maxHeight * aspectRatio;
                    }
                    
                    // Zentriere Bild
                    const x = (pdfWidth - imgWidth) / 2;
                    const y = (pdfHeight - imgHeight) / 2;

                    // F√ºge Bild zu PDF hinzu
                    pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);

                    // Speichere PDF
                    const fileName = `${this.fileName}.pdf`;
                    pdf.save(fileName);
                    
                    this.log(`‚úì PDF gespeichert: ${fileName}`, 'active');

                } catch (error) {
                    this.log(`‚úó Fehler: ${error.message}`, 'error');
                    console.error('PDF Error:', error);
                    alert('PDF-Fehler: ' + error.message);
                }
            },

            download(id) {
                // Validierung
                if(!this.vectorData) {
                    alert('Bitte zuerst ein Bild vektorisieren!');
                    this.log('Download abgebrochen: Keine Daten', 'error');
                    return;
                }
                
                const fmt = FORMATS.find(f => f.id === id);
                if (!fmt) {
                    alert('Format nicht gefunden!');
                    this.log(`Download abgebrochen: Format "${id}" nicht gefunden`, 'error');
                    return;
                }
                
                if (!this.outputs[id]) {
                    alert('Datei wurde noch nicht generiert. Bitte warten...');
                    this.log(`Download abgebrochen: Output f√ºr "${id}" nicht vorhanden`, 'error');
                    return;
                }
                
                try {
                    this.log(`Starte Download: ${this.fileName}.${fmt.ext}...`, 'active');
                    
                    // Erstelle Blob
                    const blob = new Blob([this.outputs[id]], {type: fmt.mime});
                    const url = URL.createObjectURL(blob);
                    
                    // Erstelle versteckten Download-Link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${this.fileName}.${fmt.ext}`;
                    a.style.display = 'none';
                    
                    // F√ºge zum DOM hinzu
                    document.body.appendChild(a);
                    
                    // Triggere Download
                    a.click();
                    
                    // Cleanup mit Verz√∂gerung (wichtig f√ºr manche Browser!)
                    setTimeout(() => {
                        try {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        } catch(e) {
                            console.warn('Cleanup error:', e);
                        }
                    }, 150);
                    
                    this.log(`‚úì ${fmt.label} heruntergeladen: ${this.fileName}.${fmt.ext}`, 'active');
                    
                } catch (error) {
                    alert('Fehler beim Download:\n' + error.message);
                    this.log(`‚úó Download-Fehler: ${error.message}`, 'error');
                    console.error('Download error:', error);
                }
            }
        };

        App.init();
    </script>
</body>
</html>